// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	CivilianAirports           map[*CivilianAirport]struct{}
	CivilianAirports_mapString map[string]*CivilianAirport

	Liners           map[*Liner]struct{}
	Liners_mapString map[string]*Liner

	Messages           map[*Message]struct{}
	Messages_mapString map[string]*Message

	OpsLines           map[*OpsLine]struct{}
	OpsLines_mapString map[string]*OpsLine

	Orders           map[*Order]struct{}
	Orders_mapString map[string]*Order

	Radars           map[*Radar]struct{}
	Radars_mapString map[string]*Radar

	Reports           map[*Report]struct{}
	Reports_mapString map[string]*Report

	Scenarios           map[*Scenario]struct{}
	Scenarios_mapString map[string]*Scenario

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback OnInitCommitInterface
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	BackupXL(stage *StageStruct, dirPath string)
	RestoreXL(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitCivilianAirport(civilianairport *CivilianAirport)
	CheckoutCivilianAirport(civilianairport *CivilianAirport)
	CommitLiner(liner *Liner)
	CheckoutLiner(liner *Liner)
	CommitMessage(message *Message)
	CheckoutMessage(message *Message)
	CommitOpsLine(opsline *OpsLine)
	CheckoutOpsLine(opsline *OpsLine)
	CommitOrder(order *Order)
	CheckoutOrder(order *Order)
	CommitRadar(radar *Radar)
	CheckoutRadar(radar *Radar)
	CommitReport(report *Report)
	CheckoutReport(report *Report)
	CommitScenario(scenario *Scenario)
	CheckoutScenario(scenario *Scenario)
	GetLastCommitNb() uint
	GetLastPushFromFrontNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	CivilianAirports:           make(map[*CivilianAirport]struct{}),
	CivilianAirports_mapString: make(map[string]*CivilianAirport),

	Liners:           make(map[*Liner]struct{}),
	Liners_mapString: make(map[string]*Liner),

	Messages:           make(map[*Message]struct{}),
	Messages_mapString: make(map[string]*Message),

	OpsLines:           make(map[*OpsLine]struct{}),
	OpsLines_mapString: make(map[string]*OpsLine),

	Orders:           make(map[*Order]struct{}),
	Orders_mapString: make(map[string]*Order),

	Radars:           make(map[*Radar]struct{}),
	Radars_mapString: make(map[string]*Radar),

	Reports:           make(map[*Report]struct{}),
	Reports_mapString: make(map[string]*Report),

	Scenarios:           make(map[*Scenario]struct{}),
	Scenarios_mapString: make(map[string]*Scenario),

	// end of insertion point
}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) BackupXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.BackupXL(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) RestoreXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.RestoreXL(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getCivilianAirportOrderedStructWithNameField() []*CivilianAirport {
	// have alphabetical order generation
	civilianairportOrdered := []*CivilianAirport{}
	for civilianairport := range stage.CivilianAirports {
		civilianairportOrdered = append(civilianairportOrdered, civilianairport)
	}
	sort.Slice(civilianairportOrdered[:], func(i, j int) bool {
		return civilianairportOrdered[i].Name < civilianairportOrdered[j].Name
	})
	return civilianairportOrdered
}

// Stage puts civilianairport to the model stage
func (civilianairport *CivilianAirport) Stage() *CivilianAirport {
	Stage.CivilianAirports[civilianairport] = __member
	Stage.CivilianAirports_mapString[civilianairport.Name] = civilianairport

	return civilianairport
}

// Unstage removes civilianairport off the model stage
func (civilianairport *CivilianAirport) Unstage() *CivilianAirport {
	delete(Stage.CivilianAirports, civilianairport)
	delete(Stage.CivilianAirports_mapString, civilianairport.Name)
	return civilianairport
}

// commit civilianairport to the back repo (if it is already staged)
func (civilianairport *CivilianAirport) Commit() *CivilianAirport {
	if _, ok := Stage.CivilianAirports[civilianairport]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitCivilianAirport(civilianairport)
		}
	}
	return civilianairport
}

// Checkout civilianairport to the back repo (if it is already staged)
func (civilianairport *CivilianAirport) Checkout() *CivilianAirport {
	if _, ok := Stage.CivilianAirports[civilianairport]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutCivilianAirport(civilianairport)
		}
	}
	return civilianairport
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of civilianairport to the model stage
func (civilianairport *CivilianAirport) StageCopy() *CivilianAirport {
	_civilianairport := new(CivilianAirport)
	*_civilianairport = *civilianairport
	_civilianairport.Stage()
	return _civilianairport
}

// StageAndCommit appends civilianairport to the model stage and commit to the orm repo
func (civilianairport *CivilianAirport) StageAndCommit() *CivilianAirport {
	civilianairport.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMCivilianAirport(civilianairport)
	}
	return civilianairport
}

// DeleteStageAndCommit appends civilianairport to the model stage and commit to the orm repo
func (civilianairport *CivilianAirport) DeleteStageAndCommit() *CivilianAirport {
	civilianairport.Unstage()
	DeleteORMCivilianAirport(civilianairport)
	return civilianairport
}

// StageCopyAndCommit appends a copy of civilianairport to the model stage and commit to the orm repo
func (civilianairport *CivilianAirport) StageCopyAndCommit() *CivilianAirport {
	_civilianairport := new(CivilianAirport)
	*_civilianairport = *civilianairport
	_civilianairport.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMCivilianAirport(civilianairport)
	}
	return _civilianairport
}

// CreateORMCivilianAirport enables dynamic staging of a CivilianAirport instance
func CreateORMCivilianAirport(civilianairport *CivilianAirport) {
	civilianairport.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMCivilianAirport(civilianairport)
	}
}

// DeleteORMCivilianAirport enables dynamic staging of a CivilianAirport instance
func DeleteORMCivilianAirport(civilianairport *CivilianAirport) {
	civilianairport.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMCivilianAirport(civilianairport)
	}
}

func (stage *StageStruct) getLinerOrderedStructWithNameField() []*Liner {
	// have alphabetical order generation
	linerOrdered := []*Liner{}
	for liner := range stage.Liners {
		linerOrdered = append(linerOrdered, liner)
	}
	sort.Slice(linerOrdered[:], func(i, j int) bool {
		return linerOrdered[i].Name < linerOrdered[j].Name
	})
	return linerOrdered
}

// Stage puts liner to the model stage
func (liner *Liner) Stage() *Liner {
	Stage.Liners[liner] = __member
	Stage.Liners_mapString[liner.Name] = liner

	return liner
}

// Unstage removes liner off the model stage
func (liner *Liner) Unstage() *Liner {
	delete(Stage.Liners, liner)
	delete(Stage.Liners_mapString, liner.Name)
	return liner
}

// commit liner to the back repo (if it is already staged)
func (liner *Liner) Commit() *Liner {
	if _, ok := Stage.Liners[liner]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLiner(liner)
		}
	}
	return liner
}

// Checkout liner to the back repo (if it is already staged)
func (liner *Liner) Checkout() *Liner {
	if _, ok := Stage.Liners[liner]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLiner(liner)
		}
	}
	return liner
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of liner to the model stage
func (liner *Liner) StageCopy() *Liner {
	_liner := new(Liner)
	*_liner = *liner
	_liner.Stage()
	return _liner
}

// StageAndCommit appends liner to the model stage and commit to the orm repo
func (liner *Liner) StageAndCommit() *Liner {
	liner.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLiner(liner)
	}
	return liner
}

// DeleteStageAndCommit appends liner to the model stage and commit to the orm repo
func (liner *Liner) DeleteStageAndCommit() *Liner {
	liner.Unstage()
	DeleteORMLiner(liner)
	return liner
}

// StageCopyAndCommit appends a copy of liner to the model stage and commit to the orm repo
func (liner *Liner) StageCopyAndCommit() *Liner {
	_liner := new(Liner)
	*_liner = *liner
	_liner.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLiner(liner)
	}
	return _liner
}

// CreateORMLiner enables dynamic staging of a Liner instance
func CreateORMLiner(liner *Liner) {
	liner.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLiner(liner)
	}
}

// DeleteORMLiner enables dynamic staging of a Liner instance
func DeleteORMLiner(liner *Liner) {
	liner.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMLiner(liner)
	}
}

func (stage *StageStruct) getMessageOrderedStructWithNameField() []*Message {
	// have alphabetical order generation
	messageOrdered := []*Message{}
	for message := range stage.Messages {
		messageOrdered = append(messageOrdered, message)
	}
	sort.Slice(messageOrdered[:], func(i, j int) bool {
		return messageOrdered[i].Name < messageOrdered[j].Name
	})
	return messageOrdered
}

// Stage puts message to the model stage
func (message *Message) Stage() *Message {
	Stage.Messages[message] = __member
	Stage.Messages_mapString[message.Name] = message

	return message
}

// Unstage removes message off the model stage
func (message *Message) Unstage() *Message {
	delete(Stage.Messages, message)
	delete(Stage.Messages_mapString, message.Name)
	return message
}

// commit message to the back repo (if it is already staged)
func (message *Message) Commit() *Message {
	if _, ok := Stage.Messages[message]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitMessage(message)
		}
	}
	return message
}

// Checkout message to the back repo (if it is already staged)
func (message *Message) Checkout() *Message {
	if _, ok := Stage.Messages[message]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutMessage(message)
		}
	}
	return message
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of message to the model stage
func (message *Message) StageCopy() *Message {
	_message := new(Message)
	*_message = *message
	_message.Stage()
	return _message
}

// StageAndCommit appends message to the model stage and commit to the orm repo
func (message *Message) StageAndCommit() *Message {
	message.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMMessage(message)
	}
	return message
}

// DeleteStageAndCommit appends message to the model stage and commit to the orm repo
func (message *Message) DeleteStageAndCommit() *Message {
	message.Unstage()
	DeleteORMMessage(message)
	return message
}

// StageCopyAndCommit appends a copy of message to the model stage and commit to the orm repo
func (message *Message) StageCopyAndCommit() *Message {
	_message := new(Message)
	*_message = *message
	_message.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMMessage(message)
	}
	return _message
}

// CreateORMMessage enables dynamic staging of a Message instance
func CreateORMMessage(message *Message) {
	message.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMMessage(message)
	}
}

// DeleteORMMessage enables dynamic staging of a Message instance
func DeleteORMMessage(message *Message) {
	message.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMMessage(message)
	}
}

func (stage *StageStruct) getOpsLineOrderedStructWithNameField() []*OpsLine {
	// have alphabetical order generation
	opslineOrdered := []*OpsLine{}
	for opsline := range stage.OpsLines {
		opslineOrdered = append(opslineOrdered, opsline)
	}
	sort.Slice(opslineOrdered[:], func(i, j int) bool {
		return opslineOrdered[i].Name < opslineOrdered[j].Name
	})
	return opslineOrdered
}

// Stage puts opsline to the model stage
func (opsline *OpsLine) Stage() *OpsLine {
	Stage.OpsLines[opsline] = __member
	Stage.OpsLines_mapString[opsline.Name] = opsline

	return opsline
}

// Unstage removes opsline off the model stage
func (opsline *OpsLine) Unstage() *OpsLine {
	delete(Stage.OpsLines, opsline)
	delete(Stage.OpsLines_mapString, opsline.Name)
	return opsline
}

// commit opsline to the back repo (if it is already staged)
func (opsline *OpsLine) Commit() *OpsLine {
	if _, ok := Stage.OpsLines[opsline]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitOpsLine(opsline)
		}
	}
	return opsline
}

// Checkout opsline to the back repo (if it is already staged)
func (opsline *OpsLine) Checkout() *OpsLine {
	if _, ok := Stage.OpsLines[opsline]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutOpsLine(opsline)
		}
	}
	return opsline
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of opsline to the model stage
func (opsline *OpsLine) StageCopy() *OpsLine {
	_opsline := new(OpsLine)
	*_opsline = *opsline
	_opsline.Stage()
	return _opsline
}

// StageAndCommit appends opsline to the model stage and commit to the orm repo
func (opsline *OpsLine) StageAndCommit() *OpsLine {
	opsline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOpsLine(opsline)
	}
	return opsline
}

// DeleteStageAndCommit appends opsline to the model stage and commit to the orm repo
func (opsline *OpsLine) DeleteStageAndCommit() *OpsLine {
	opsline.Unstage()
	DeleteORMOpsLine(opsline)
	return opsline
}

// StageCopyAndCommit appends a copy of opsline to the model stage and commit to the orm repo
func (opsline *OpsLine) StageCopyAndCommit() *OpsLine {
	_opsline := new(OpsLine)
	*_opsline = *opsline
	_opsline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOpsLine(opsline)
	}
	return _opsline
}

// CreateORMOpsLine enables dynamic staging of a OpsLine instance
func CreateORMOpsLine(opsline *OpsLine) {
	opsline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOpsLine(opsline)
	}
}

// DeleteORMOpsLine enables dynamic staging of a OpsLine instance
func DeleteORMOpsLine(opsline *OpsLine) {
	opsline.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMOpsLine(opsline)
	}
}

func (stage *StageStruct) getOrderOrderedStructWithNameField() []*Order {
	// have alphabetical order generation
	orderOrdered := []*Order{}
	for order := range stage.Orders {
		orderOrdered = append(orderOrdered, order)
	}
	sort.Slice(orderOrdered[:], func(i, j int) bool {
		return orderOrdered[i].Name < orderOrdered[j].Name
	})
	return orderOrdered
}

// Stage puts order to the model stage
func (order *Order) Stage() *Order {
	Stage.Orders[order] = __member
	Stage.Orders_mapString[order.Name] = order

	return order
}

// Unstage removes order off the model stage
func (order *Order) Unstage() *Order {
	delete(Stage.Orders, order)
	delete(Stage.Orders_mapString, order.Name)
	return order
}

// commit order to the back repo (if it is already staged)
func (order *Order) Commit() *Order {
	if _, ok := Stage.Orders[order]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitOrder(order)
		}
	}
	return order
}

// Checkout order to the back repo (if it is already staged)
func (order *Order) Checkout() *Order {
	if _, ok := Stage.Orders[order]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutOrder(order)
		}
	}
	return order
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of order to the model stage
func (order *Order) StageCopy() *Order {
	_order := new(Order)
	*_order = *order
	_order.Stage()
	return _order
}

// StageAndCommit appends order to the model stage and commit to the orm repo
func (order *Order) StageAndCommit() *Order {
	order.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOrder(order)
	}
	return order
}

// DeleteStageAndCommit appends order to the model stage and commit to the orm repo
func (order *Order) DeleteStageAndCommit() *Order {
	order.Unstage()
	DeleteORMOrder(order)
	return order
}

// StageCopyAndCommit appends a copy of order to the model stage and commit to the orm repo
func (order *Order) StageCopyAndCommit() *Order {
	_order := new(Order)
	*_order = *order
	_order.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOrder(order)
	}
	return _order
}

// CreateORMOrder enables dynamic staging of a Order instance
func CreateORMOrder(order *Order) {
	order.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMOrder(order)
	}
}

// DeleteORMOrder enables dynamic staging of a Order instance
func DeleteORMOrder(order *Order) {
	order.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMOrder(order)
	}
}

func (stage *StageStruct) getRadarOrderedStructWithNameField() []*Radar {
	// have alphabetical order generation
	radarOrdered := []*Radar{}
	for radar := range stage.Radars {
		radarOrdered = append(radarOrdered, radar)
	}
	sort.Slice(radarOrdered[:], func(i, j int) bool {
		return radarOrdered[i].Name < radarOrdered[j].Name
	})
	return radarOrdered
}

// Stage puts radar to the model stage
func (radar *Radar) Stage() *Radar {
	Stage.Radars[radar] = __member
	Stage.Radars_mapString[radar.Name] = radar

	return radar
}

// Unstage removes radar off the model stage
func (radar *Radar) Unstage() *Radar {
	delete(Stage.Radars, radar)
	delete(Stage.Radars_mapString, radar.Name)
	return radar
}

// commit radar to the back repo (if it is already staged)
func (radar *Radar) Commit() *Radar {
	if _, ok := Stage.Radars[radar]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitRadar(radar)
		}
	}
	return radar
}

// Checkout radar to the back repo (if it is already staged)
func (radar *Radar) Checkout() *Radar {
	if _, ok := Stage.Radars[radar]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutRadar(radar)
		}
	}
	return radar
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of radar to the model stage
func (radar *Radar) StageCopy() *Radar {
	_radar := new(Radar)
	*_radar = *radar
	_radar.Stage()
	return _radar
}

// StageAndCommit appends radar to the model stage and commit to the orm repo
func (radar *Radar) StageAndCommit() *Radar {
	radar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRadar(radar)
	}
	return radar
}

// DeleteStageAndCommit appends radar to the model stage and commit to the orm repo
func (radar *Radar) DeleteStageAndCommit() *Radar {
	radar.Unstage()
	DeleteORMRadar(radar)
	return radar
}

// StageCopyAndCommit appends a copy of radar to the model stage and commit to the orm repo
func (radar *Radar) StageCopyAndCommit() *Radar {
	_radar := new(Radar)
	*_radar = *radar
	_radar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRadar(radar)
	}
	return _radar
}

// CreateORMRadar enables dynamic staging of a Radar instance
func CreateORMRadar(radar *Radar) {
	radar.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRadar(radar)
	}
}

// DeleteORMRadar enables dynamic staging of a Radar instance
func DeleteORMRadar(radar *Radar) {
	radar.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMRadar(radar)
	}
}

func (stage *StageStruct) getReportOrderedStructWithNameField() []*Report {
	// have alphabetical order generation
	reportOrdered := []*Report{}
	for report := range stage.Reports {
		reportOrdered = append(reportOrdered, report)
	}
	sort.Slice(reportOrdered[:], func(i, j int) bool {
		return reportOrdered[i].Name < reportOrdered[j].Name
	})
	return reportOrdered
}

// Stage puts report to the model stage
func (report *Report) Stage() *Report {
	Stage.Reports[report] = __member
	Stage.Reports_mapString[report.Name] = report

	return report
}

// Unstage removes report off the model stage
func (report *Report) Unstage() *Report {
	delete(Stage.Reports, report)
	delete(Stage.Reports_mapString, report.Name)
	return report
}

// commit report to the back repo (if it is already staged)
func (report *Report) Commit() *Report {
	if _, ok := Stage.Reports[report]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitReport(report)
		}
	}
	return report
}

// Checkout report to the back repo (if it is already staged)
func (report *Report) Checkout() *Report {
	if _, ok := Stage.Reports[report]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutReport(report)
		}
	}
	return report
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of report to the model stage
func (report *Report) StageCopy() *Report {
	_report := new(Report)
	*_report = *report
	_report.Stage()
	return _report
}

// StageAndCommit appends report to the model stage and commit to the orm repo
func (report *Report) StageAndCommit() *Report {
	report.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMReport(report)
	}
	return report
}

// DeleteStageAndCommit appends report to the model stage and commit to the orm repo
func (report *Report) DeleteStageAndCommit() *Report {
	report.Unstage()
	DeleteORMReport(report)
	return report
}

// StageCopyAndCommit appends a copy of report to the model stage and commit to the orm repo
func (report *Report) StageCopyAndCommit() *Report {
	_report := new(Report)
	*_report = *report
	_report.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMReport(report)
	}
	return _report
}

// CreateORMReport enables dynamic staging of a Report instance
func CreateORMReport(report *Report) {
	report.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMReport(report)
	}
}

// DeleteORMReport enables dynamic staging of a Report instance
func DeleteORMReport(report *Report) {
	report.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMReport(report)
	}
}

func (stage *StageStruct) getScenarioOrderedStructWithNameField() []*Scenario {
	// have alphabetical order generation
	scenarioOrdered := []*Scenario{}
	for scenario := range stage.Scenarios {
		scenarioOrdered = append(scenarioOrdered, scenario)
	}
	sort.Slice(scenarioOrdered[:], func(i, j int) bool {
		return scenarioOrdered[i].Name < scenarioOrdered[j].Name
	})
	return scenarioOrdered
}

// Stage puts scenario to the model stage
func (scenario *Scenario) Stage() *Scenario {
	Stage.Scenarios[scenario] = __member
	Stage.Scenarios_mapString[scenario.Name] = scenario

	return scenario
}

// Unstage removes scenario off the model stage
func (scenario *Scenario) Unstage() *Scenario {
	delete(Stage.Scenarios, scenario)
	delete(Stage.Scenarios_mapString, scenario.Name)
	return scenario
}

// commit scenario to the back repo (if it is already staged)
func (scenario *Scenario) Commit() *Scenario {
	if _, ok := Stage.Scenarios[scenario]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitScenario(scenario)
		}
	}
	return scenario
}

// Checkout scenario to the back repo (if it is already staged)
func (scenario *Scenario) Checkout() *Scenario {
	if _, ok := Stage.Scenarios[scenario]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutScenario(scenario)
		}
	}
	return scenario
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of scenario to the model stage
func (scenario *Scenario) StageCopy() *Scenario {
	_scenario := new(Scenario)
	*_scenario = *scenario
	_scenario.Stage()
	return _scenario
}

// StageAndCommit appends scenario to the model stage and commit to the orm repo
func (scenario *Scenario) StageAndCommit() *Scenario {
	scenario.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMScenario(scenario)
	}
	return scenario
}

// DeleteStageAndCommit appends scenario to the model stage and commit to the orm repo
func (scenario *Scenario) DeleteStageAndCommit() *Scenario {
	scenario.Unstage()
	DeleteORMScenario(scenario)
	return scenario
}

// StageCopyAndCommit appends a copy of scenario to the model stage and commit to the orm repo
func (scenario *Scenario) StageCopyAndCommit() *Scenario {
	_scenario := new(Scenario)
	*_scenario = *scenario
	_scenario.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMScenario(scenario)
	}
	return _scenario
}

// CreateORMScenario enables dynamic staging of a Scenario instance
func CreateORMScenario(scenario *Scenario) {
	scenario.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMScenario(scenario)
	}
}

// DeleteORMScenario enables dynamic staging of a Scenario instance
func DeleteORMScenario(scenario *Scenario) {
	scenario.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMScenario(scenario)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMCivilianAirport(CivilianAirport *CivilianAirport)
	CreateORMLiner(Liner *Liner)
	CreateORMMessage(Message *Message)
	CreateORMOpsLine(OpsLine *OpsLine)
	CreateORMOrder(Order *Order)
	CreateORMRadar(Radar *Radar)
	CreateORMReport(Report *Report)
	CreateORMScenario(Scenario *Scenario)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMCivilianAirport(CivilianAirport *CivilianAirport)
	DeleteORMLiner(Liner *Liner)
	DeleteORMMessage(Message *Message)
	DeleteORMOpsLine(OpsLine *OpsLine)
	DeleteORMOrder(Order *Order)
	DeleteORMRadar(Radar *Radar)
	DeleteORMReport(Report *Report)
	DeleteORMScenario(Scenario *Scenario)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.CivilianAirports = make(map[*CivilianAirport]struct{})
	stage.CivilianAirports_mapString = make(map[string]*CivilianAirport)

	stage.Liners = make(map[*Liner]struct{})
	stage.Liners_mapString = make(map[string]*Liner)

	stage.Messages = make(map[*Message]struct{})
	stage.Messages_mapString = make(map[string]*Message)

	stage.OpsLines = make(map[*OpsLine]struct{})
	stage.OpsLines_mapString = make(map[string]*OpsLine)

	stage.Orders = make(map[*Order]struct{})
	stage.Orders_mapString = make(map[string]*Order)

	stage.Radars = make(map[*Radar]struct{})
	stage.Radars_mapString = make(map[string]*Radar)

	stage.Reports = make(map[*Report]struct{})
	stage.Reports_mapString = make(map[string]*Report)

	stage.Scenarios = make(map[*Scenario]struct{})
	stage.Scenarios_mapString = make(map[string]*Scenario)

}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.CivilianAirports = nil
	stage.CivilianAirports_mapString = nil

	stage.Liners = nil
	stage.Liners_mapString = nil

	stage.Messages = nil
	stage.Messages_mapString = nil

	stage.OpsLines = nil
	stage.OpsLines_mapString = nil

	stage.Orders = nil
	stage.Orders_mapString = nil

	stage.Radars = nil
	stage.Radars_mapString = nil

	stage.Reports = nil
	stage.Reports_mapString = nil

	stage.Scenarios = nil
	stage.Scenarios_mapString = nil

}
